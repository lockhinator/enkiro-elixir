# This workflow builds, tests, and pushes the production Docker image to GHCR.
# It leverages Docker's multi-stage build cache for maximum efficiency.
name: Build and Push Production Image

# Controls when the action will run.
on:
  # Triggers the workflow on push requests to the main branch.
  push:
    branches:
      - main

# A workflow run is made up of one or more jobs that can run sequentially or in parallel.
jobs:
  build_and_push:
    # The type of runner that the job will run on.
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write # Grant GITHUB_TOKEN permissions to write packages

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # 1. Check out the repository code
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Set up QEMU for multi-platform builds (optional but good practice)
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # 3. Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 4. Log in to GitHub Container Registry
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 5. Build all images from Docker Compose
      # This builds all services, including 'release' for testing and 'final' for production.
      - name: Build Docker images
        run: docker compose build

      # 6. Prepare environment file for Docker Compose
      # docker-compose will automatically use the .env file
      - name: Set up environment file
        run: cp .env.example .env

      # 7. ADD THIS STEP to create the external volume before it's needed
      - name: Create Docker volume
        run: docker volume create --name=pg-data

      # 8. Run comprehensive tests against the build
      # These steps run before the image is pushed to ensure code quality.
      - name: Run Format check and Credo checks
        run: docker compose run --rm -e MIX_ENV=test app sh -c "mix format --check-formatted && mix credo"

      # 9. Generate a secret key if needed for tests
      - name: Generate Phoenix secret key
        run: |
          SECRET=$(docker compose run --rm -T app mix phx.gen.secret)
          sed -i "s|SECRET_KEY_BASE=.*|SECRET_KEY_BASE=$SECRET|" .env

      # 10. Setup database and run tests
      # This runs all test-related commands in a single container to avoid recompilation.
      - name: Setup database and run tests
        run: docker compose run --rm -e MIX_ENV=test app sh -c "mix ecto.create && mix ecto.migrate && mix test"

      # 11. Push the final image to the registry if all tests pass
      # This pushes the slim, production-ready image from the 'final' stage.
      - name: Push image to registry
        run: docker compose push final